(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[888],{8e3:function(e,t,n){"use strict";var o;Object.defineProperty(t,"__esModule",{value:!0}),t.AmpStateContext=void 0;const r=((o=n(7294))&&o.__esModule?o:{default:o}).default.createContext({});t.AmpStateContext=r},5646:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isInAmpMode=s,t.useAmp=function(){return s(r.default.useContext(a.AmpStateContext))};var o,r=(o=n(7294))&&o.__esModule?o:{default:o},a=n(8e3);function s({ampFirst:e=!1,hybrid:t=!1,hasQuery:n=!1}={}){return e||t&&n}},2717:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.defaultHead=c,t.default=void 0;var o,r=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var o=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,n):{};o.get||o.set?Object.defineProperty(t,n,o):t[n]=e[n]}return t.default=e,t}(n(7294)),a=(o=n(1585))&&o.__esModule?o:{default:o},s=n(8e3),i=n(5850),u=n(5646);function c(e=!1){const t=[r.default.createElement("meta",{charSet:"utf-8"})];return e||t.push(r.default.createElement("meta",{name:"viewport",content:"width=device-width"})),t}function l(e,t){return"string"===typeof t||"number"===typeof t?e:t.type===r.default.Fragment?e.concat(r.default.Children.toArray(t.props.children).reduce(((e,t)=>"string"===typeof t||"number"===typeof t?e:e.concat(t)),[])):e.concat(t)}const d=["name","httpEquiv","charSet","itemProp"];function f(e,t){return e.reduce(((e,t)=>{const n=r.default.Children.toArray(t.props.children);return e.concat(n)}),[]).reduce(l,[]).reverse().concat(c(t.inAmpMode)).filter(function(){const e=new Set,t=new Set,n=new Set,o={};return r=>{let a=!0,s=!1;if(r.key&&"number"!==typeof r.key&&r.key.indexOf("$")>0){s=!0;const t=r.key.slice(r.key.indexOf("$")+1);e.has(t)?a=!1:e.add(t)}switch(r.type){case"title":case"base":t.has(r.type)?a=!1:t.add(r.type);break;case"meta":for(let e=0,t=d.length;e<t;e++){const t=d[e];if(r.props.hasOwnProperty(t))if("charSet"===t)n.has(t)?a=!1:n.add(t);else{const e=r.props[t],n=o[t]||new Set;"name"===t&&s||!n.has(e)?(n.add(e),o[t]=n):a=!1}}}return a}}()).reverse().map(((e,n)=>{const o=e.key||n;if(!t.inAmpMode&&"link"===e.type&&e.props.href&&["https://fonts.googleapis.com/css","https://use.typekit.net/"].some((t=>e.props.href.startsWith(t)))){const t={...e.props||{}};return t["data-href"]=t.href,t.href=void 0,t["data-optimized-fonts"]=!0,r.default.cloneElement(e,t)}return r.default.cloneElement(e,{key:o})}))}var h=function({children:e}){const t=r.useContext(s.AmpStateContext),n=r.useContext(i.HeadManagerContext);return r.default.createElement(a.default,{reduceComponentsToState:f,headManager:n,inAmpMode:u.isInAmpMode(t)},e)};t.default=h},1585:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var o=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,n):{};o.get||o.set?Object.defineProperty(t,n,o):t[n]=e[n]}return t.default=e,t}(n(7294));class r extends o.Component{constructor(e){super(e),this.emitChange=()=>{this._hasHeadManager&&this.props.headManager.updateHead(this.props.reduceComponentsToState([...this.props.headManager.mountedInstances],this.props))},this._hasHeadManager=this.props.headManager&&this.props.headManager.mountedInstances}componentDidMount(){this._hasHeadManager&&this.props.headManager.mountedInstances.add(this),this.emitChange()}componentDidUpdate(){this.emitChange()}componentWillUnmount(){this._hasHeadManager&&this.props.headManager.mountedInstances.delete(this),this.emitChange()}render(){return null}}t.default=r},5912:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return _a}});n(8701),n(2989);var o=n(9008),r=n(3935),a=n(7294);var s=function(e){return!!e&&"function"===typeof e.then};var i=function(e,t){if(null!=e)return e;throw new Error(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};class u{}const c=new u,l={valueMaybe(){},valueOrThrow(){throw new Error(`Loadable expected value, but in "${this.state}" state`)},errorMaybe(){},errorOrThrow(){throw new Error(`Loadable expected error, but in "${this.state}" state`)},promiseMaybe(){},promiseOrThrow(){throw new Error(`Loadable expected promise, but in "${this.state}" state`)},is(e){return e.state===this.state&&e.contents===this.contents},map(e){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const t=e(this.contents);return s(t)?h(t):d(t)}catch(t){return s(t)?h(t.next((()=>e(this.contents)))):f(t)}if("loading"===this.state)return h(this.contents.then(e).catch((t=>{if(s(t))return t.then((()=>e(this.contents)));throw t})));throw new Error("Invalid Loadable state")}};function d(e){return Object.freeze({state:"hasValue",contents:e,...l,getValue(){return this.contents},toPromise(){return Promise.resolve(this.contents)},valueMaybe(){return this.contents},valueOrThrow(){return this.contents}})}function f(e){return Object.freeze({state:"hasError",contents:e,...l,getValue(){throw this.contents},toPromise(){return Promise.reject(this.contents)},errorMaybe(){return this.contents},errorOrThrow(){return this.contents}})}function h(e){return Object.freeze({state:"loading",contents:e,...l,getValue(){throw this.contents.then((({__value:e})=>e))},toPromise(){return this.contents.then((({__value:e})=>e))},promiseMaybe(){return this.contents.then((({__value:e})=>e))},promiseOrThrow(){return this.contents.then((({__value:e})=>e))}})}var p={loadableWithValue:d,loadableWithError:f,loadableWithPromise:h,loadableLoading:function(){return h(new Promise((()=>{})))},loadableAll:function(e){return e.every((e=>"hasValue"===e.state))?d(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?f(i(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):h(Promise.all(e.map((e=>e.contents))).then((e=>({__value:e}))))},Canceled:u,CANCELED:c};var v=function(e,t,{error:n}={}){return null};var m={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var y=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};const _=(new Map).set("recoil_hamt_2020",!0).set("recoil_memory_managament_2020",!0);function g(e){var t;return null!==(t=_.get(e))&&void 0!==t&&t}g.setPass=e=>{_.set(e,!0)},g.setFail=e=>{_.set(e,!1)};var S=g;var w=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var b=function(e,...t){0};function T(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class R{constructor(e){T(this,"key",void 0),this.key=e}}class A extends R{}class E extends R{}var k={AbstractRecoilValue:R,RecoilState:A,RecoilValueReadOnly:E,isRecoilValue:function(e){return e instanceof A||e instanceof E}},N=k.AbstractRecoilValue,V=k.RecoilState,M=k.RecoilValueReadOnly,C=k.isRecoilValue,L=Object.freeze({__proto__:null,AbstractRecoilValue:N,RecoilState:V,RecoilValueReadOnly:M,isRecoilValue:C});class x{}const D=new x;class B extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const U=new Map,O=new Map;class I extends Error{}const P=new Map;function z(e){return P.get(e)}var F={nodes:U,recoilValues:O,registerNode:function(e){if(U.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}U.set(e.key,e);const t=null==e.set?new L.RecoilValueReadOnly(e.key):new L.RecoilState(e.key);return O.set(e.key,t),t},getNode:function(e){const t=U.get(e);if(null==t)throw new I(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return U.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!S("recoil_memory_managament_2020"))return;const n=U.get(e);var o;(null===n||void 0===n||null===(t=n.shouldDeleteConfigOnRelease)||void 0===t?void 0:t.call(n))&&(U.delete(e),null===(o=z(e))||void 0===o||o(),P.delete(e))},setConfigDeletionHandler:function(e,t){S("recoil_memory_managament_2020")&&(void 0===t?P.delete(e):P.set(e,t))},getConfigDeletionHandler:z,recoilValuesForKeys:function(e){return w(e,(e=>i(O.get(e))))},NodeMissingError:I,DefaultValue:x,DEFAULT_VALUE:D,RecoilValueNotReady:B};class j{}var H={RetentionZone:j,retentionZone:function(){return new j}};const{setByAddingToSet:$}=m,{getNode:G,getNodeMaybe:W,recoilValuesForKeys:q}=F,{RetentionZone:K}=H,Z=Object.freeze(new Set);class J extends Error{}function X(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=G(n),s=function(e,t,n){if(!S("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof K)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!S("recoil_memory_managament_2020"))return;const o=e.getState().retention.nodesRetainedByZone;function r(e){const n=o.get(e);n&&n.delete(t),n&&0===n.size&&o.delete(e)}if(n instanceof K)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),i=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{i(),s()}))}function Q(e,t,n){return G(n).peek(e,t)}function Y(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let i=r.pop();i;i=r.pop()){var s;o.add(i);const e=null!==(s=a.nodeToNodeSubscriptions.get(i))&&void 0!==s?s:Z;for(const t of e)o.has(t)||r.push(t)}return o}var ee={getNodeLoadable:function(e,t,n){return X(e,t,n,"get"),G(n).get(e,t)},peekNodeLoadable:Q,setNodeValue:function(e,t,n,o){const r=G(n);if(null==r.set)throw new J(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return X(e,t,n,"set"),a(e,t,o)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=W(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:$(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){var o,r,a;const s=e.getState(),i=e.getGraph(t.version),u=s.knownAtoms.has(n)?"atom":s.knownSelectors.has(n)?"selector":void 0,c=y(Y(e,t,new Set([n])),(e=>e!==n));return{loadable:Q(e,t,n),isActive:s.knownAtoms.has(n)||s.knownSelectors.has(n),isSet:"selector"!==u&&t.atomValues.has(n),isModified:t.dirtyAtoms.has(n),type:u,deps:q(null!==(o=i.nodeDeps.get(n))&&void 0!==o?o:[]),subscribers:{nodes:q(c),components:w(null!==(r=null===(a=s.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}},getDownstreamNodes:Y,initializeNodeIfNewToStore:X};const{CANCELED:te}=p,{getDownstreamNodes:ne,getNodeLoadable:oe,setNodeValue:re}=ee,{getNodeMaybe:ae}=F,{DefaultValue:se,RecoilValueNotReady:ie}=F,{AbstractRecoilValue:ue,RecoilState:ce,RecoilValueReadOnly:le,isRecoilValue:de}=L;function fe(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=oe(e,t,n);if("loading"===r.state)throw new ie(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),s=re(e,t,o.key,a);for(const[e,n]of s.entries())he(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;he(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=ae(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else v(`Unknown action ${n.type}`)}function he(e,t,n){"hasValue"===n.state&&n.contents instanceof se?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function pe(e,t){e.replaceState((n=>{const o=function(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}(n);for(const r of t)fe(e,o,r);return ye(e,o),o}))}function ve(e,t){if(me.length){const n=me[me.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else pe(e,[t])}const me=[];function ye(e,t){const n=ne(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=ae(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function _e(e,t,n){ve(e,{type:"set",recoilValue:t,valueOrUpdater:n})}let ge=0;var Se={RecoilValueReadOnly:le,AbstractRecoilValue:ue,RecoilState:ce,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&v("Tried to read from a discarded tree");const s=oe(e,n,t);return"loading"===s.state&&s.contents.catch((()=>te)),s},setRecoilValue:_e,setRecoilValueLoadable:function(e,t,n){if(n instanceof se)return _e(e,t,n);ve(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){ve(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){ve(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=ge++,a=e.getState();return a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),i(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]),{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):v(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:de,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof se?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return me.push(e),()=>{for(const[t,n]of e)pe(t,n);me.pop()!==e&&v("Incorrect order of batch popping")}},invalidateDownstreams_FOR_TESTING:ye};const{unstable_batchedUpdates:we}=r;var be={unstable_batchedUpdates:we};const{unstable_batchedUpdates:Te}=be;var Re={unstable_batchedUpdates:Te};const{batchStart:Ae}=Se,{unstable_batchedUpdates:Ee}=Re;let ke=Ee;var Ne={getBatcher:()=>ke,setBatcher:e=>{ke=e},batchUpdates:e=>{ke((()=>{let t=()=>{};try{t=Ae(),e()}finally{t()}}))}};var Ve={enqueueExecution:function(e,t){t()}};var Me=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var Ce=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function Le(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:Me(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);i(r.get(e)).add(t)})),a){Me(a,e).forEach((e=>{if(!r.has(e))return;const n=i(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var xe={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),i(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:Ce(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:Ce(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=i(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&v("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(Le(e,u),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){Le(e,t.getGraph(i.currentTree.version),u)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var c;const n=null===(c=i.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){Le(e,t.getGraph(n),u)}}}};var De,Be=(function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,s=o/4,i={},u=function(e){return function(){return e}},c=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r)o=(o<<5)-o+e.charCodeAt(r)|0;return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var s=0;s<a;++s)r[s]=o[s]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,s=n;if(e)r=a=t;else for(s=new Array(o);r<t;)s[a++]=n[r++];for(++r;r<=o;)s[a++]=n[r++];return e&&(s.length=o),s},v={__hamt_isEmpty:!0},m=function(e){return e===v||e&&e.__hamt_isEmpty},y=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:T}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:R}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},w=function e(t,n,o,r,a,s){if(o===a)return _(t,o,[s,r]);var i=l(n,o),u=l(n,a);return g(t,d(i)|d(u),i===u?[e(t,n+5,o,r,a,s)]:i<u?[r,s]:[s,r])},b=function(e,t){return e===t.edit},T=function(e,t,n,o,r,a,s){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===i?(--s.value,v):b(e,this)?(this.value=u,this):y(e,r,a,u)}var c=o();return c===i?this:(++s.value,w(e,n,this.hash,this,r,y(e,r,a,c)))},R=function(e,t,n,o,r,a,s){if(r===this.hash){var u=function(e,t,n,o,r,a,s,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(s,d.key)){var f=d.value,v=a(f);return v===f?r:v===i?(--u.value,p(e,l,r)):h(e,l,y(t,o,s,v),r)}}var m=a();return m===i?r:(++u.value,h(e,c,y(t,o,s,m),r))}(b(e,this),e,t,this.hash,this.children,o,a,s);return u===this.children?this:u.length>1?_(e,this.hash,u):u[0]}var c=o();return c===i?this:(++s.value,w(e,n,this.hash,this,r,y(e,r,a,c)))},A=function(e,t,n,o,r,s,i){var u=this.mask,c=this.children,y=l(n,r),_=d(y),w=f(u,_),T=u&_,R=T?c[w]:v,A=R._modify(e,t,n+5,o,r,s,i);if(R===A)return this;var E,k=b(e,this),N=u,V=void 0;if(T&&m(A)){if(!(N&=~_))return v;if(c.length<=2&&((E=c[1^w])===v||1===E.type||2===E.type))return c[1^w];V=p(k,w,c)}else if(T||m(A))V=h(k,w,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],s=o,i=0,u=0;s;++u)1&s&&(a[u]=r[i++]),s>>>=1;return a[t]=n,S(e,i+1,a)}(e,y,A,u,c);N|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var s=0,i=0,u=new Array(r+1);s<t;)u[i++]=o[s++];for(u[t]=n;s<r;)u[++i]=o[s++];return u}(k,w,A,c)}return k?(this.mask=N,this.children=V,this):g(e,N,V)},E=function(e,t,n,o,r,a,i){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,i);if(f===p)return this;var y=b(e,this),_=void 0;if(m(f)&&!m(p))++u,_=h(y,d,p,c);else if(!m(f)&&m(p)){if(--u<=s)return function(e,t,n,o){for(var r=new Array(t-1),a=0,s=0,i=0,u=o.length;i<u;++i)if(i!==n){var c=o[i];c&&!m(c)&&(r[a++]=c,s|=1<<i)}return g(e,s,r)}(e,u,d,c);_=h(y,d,v,c)}else _=h(y,d,p,c);return y?(this.size=u,this.children=_,this):S(e,u,_)};function k(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,s){var u=o();return u===i?v:(++s.value,y(e,r,a,u))},k.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new k(this._editable,this._edit,this._config,e,t)};var N=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,s=o._config.keyEq;;)switch(r.type){case 1:return s(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var i=r.children,u=0,c=i.length;u<c;++u){var h=i[u];if(s(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};k.prototype.tryGetHash=function(e,t,n){return N(e,t,n,this)};var V=n.tryGet=function(e,t,n){return N(e,n._config.hash(t),t,n)};k.prototype.tryGet=function(e,t){return V(e,t,this)};var M=n.getHash=function(e,t,n){return N(void 0,e,t,n)};k.prototype.getHash=function(e,t){return M(e,t,this)},n.get=function(e,t){return N(void 0,t._config.hash(e),e,t)},k.prototype.get=function(e,t){return V(t,e,this)};var C=n.has=function(e,t,n){return N(i,e,t,n)!==i};k.prototype.hasHash=function(e,t){return C(e,t,this)};var L=n.has=function(e,t){return C(t._config.hash(e),e,t)};k.prototype.has=function(e){return L(e,this)};var x=function(e,t){return e===t};n.make=function(e){return new k(0,0,{keyEq:e&&e.keyEq||x,hash:e&&e.hash||c},v,0)},n.empty=n.make();var D=n.isEmpty=function(e){return e&&!!m(e._root)};k.prototype.isEmpty=function(){return D(this)};var B=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};k.prototype.modifyHash=function(e,t,n){return B(n,e,t,this)};var U=n.modify=function(e,t,n){return B(e,n._config.hash(t),t,n)};k.prototype.modify=function(e,t){return U(t,e,this)};var O=n.setHash=function(e,t,n,o){return B(u(n),e,t,o)};k.prototype.setHash=function(e,t,n){return O(e,t,n,this)};var I=n.set=function(e,t,n){return O(n._config.hash(e),e,t,n)};k.prototype.set=function(e,t){return I(e,t,this)};var P=u(i),z=n.removeHash=function(e,t,n){return B(P,e,t,n)};k.prototype.removeHash=k.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};k.prototype.remove=k.prototype.delete=function(e){return F(e,this)};var j=n.beginMutation=function(e){return new k(e._editable+1,e._edit+1,e._config,e._root,e._size)};k.prototype.beginMutation=function(){return j(this)};var H=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};k.prototype.endMutation=function(){return H(this)};var $=n.mutate=function(e,t){var n=j(t);return e(n),H(n)};k.prototype.mutate=function(e){return $(e,this)};var G=function(e){return e&&W(e[0],e[1],e[2],e[3],e[4])},W=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!m(a))return q(a,o,[e,t,n,o,r])}return G(r)},q=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return W(o.length,o,0,t,n);default:return G(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=G(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z(q(e._root,t))},X=function(e){return[e.key,e.value]},Q=n.entries=function(e){return J(e,X)};k.prototype.entries=k.prototype[Symbol.iterator]=function(){return Q(this)};var Y=function(e){return e.key},ee=n.keys=function(e){return J(e,Y)};k.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=k.prototype.values=function(e){return J(e,te)};k.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var s=0,i=a.length;s<i;){var u=a[s++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};k.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};k.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};k.prototype.count=function(){return ae(this)},Object.defineProperty(k.prototype,"size",{get:k.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}(De={exports:{}},De.exports),De.exports);class Ue{constructor(e){T(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return Ie(this)}toMap(){return new Map(this._map)}}class Oe{constructor(e){if(T(this,"_hamt",Be.empty.beginMutation()),e instanceof Oe){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return Ie(this)}toMap(){return new Map(this._hamt)}}function Ie(e){return S("recoil_hamt_2020")?new Oe(e):new Ue(e)}var Pe=Ie,ze=Object.freeze({__proto__:null,persistentMap:Pe});const{graph:Fe}=xe,{persistentMap:je}=ze;let He=0;const $e=()=>He++;function Ge(){const e=$e();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:je(),nonvalidatedAtoms:je()}}var We={makeEmptyTreeState:Ge,makeEmptyStoreState:function(){const e=Ge();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,Fe()),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:$e};var qe=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};var Ke=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:Ze}=ee,{deleteNodeConfigIfPossible:Je,getNode:Xe}=F,{RetentionZone:Qe}=H,Ye=new Set;function et(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void v("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const s of t)if(s instanceof Qe)for(const e of nt(n,s))r.add(e);else r.add(s);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return u(t),a;function u(t){const c=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),s=[],u=new Set;for(;n.size>0;)c(i(n.values().next().value));return s;function c(e){if(o.has(e)||r.has(e))return void n.delete(e);if(u.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)c(n);u.add(e),n.delete(e),s.push(e)}}(e,o,t,a,s);for(const e of l){var d;if("recoilRoot"===Xe(e).retainedBy){s.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){s.add(e);continue}if(ot(e).some((e=>n.retention.referenceCounts.get(e)))){s.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&Ke(t,(e=>s.has(e)))?s.add(e):(a.add(e),c.add(e))}const f=new Set;for(const e of c)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:Ye){var h;a.has(t)||f.add(t)}f.size&&u(f)}}(e,r);for(const s of a)tt(e,o,s)}function tt(e,t,n){if(!S("recoil_memory_managament_2020"))return;Ze(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=ot(n);for(const u of r){var a;null===(a=o.retention.nodesRetainedByZone.get(u))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const e=s.nodeDeps.get(n);if(void 0!==e){s.nodeDeps.delete(n);for(const t of e){var i;null===(i=s.nodeToNodeSubscriptions.get(t))||void 0===i||i.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}Je(n)}function nt(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:Ye}function ot(e){const t=Xe(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof Qe?[t]:t}function rt(e,t){if(!S("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):et(e,new Set([t]))}(e,t)}var at={updateRetainCount:function(e,t,n){var o;if(!S("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?rt(e,t):r.set(t,a)},updateRetainCountToZero:rt,releaseScheduledRetainablesNow:function(e){if(!S("recoil_memory_managament_2020"))return;const t=e.getState();et(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};var st=function*(e){for(const t of e)for(const e of t)yield e};var it={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};const{isSSR:ut}=it,{batchUpdates:ct}=Ne,{initializeNodeIfNewToStore:lt,peekNodeInfo:dt}=ee,{graph:ft}=xe,{DEFAULT_VALUE:ht,recoilValues:pt,recoilValuesForKeys:vt}=F,{AbstractRecoilValue:mt,getRecoilValueAsLoadable:yt,setRecoilValue:_t,setUnvalidatedRecoilValue:gt}=Se,{updateRetainCount:St,updateRetainCountToZero:wt}=at,{getNextTreeStateVersion:bt,makeEmptyStoreState:Tt}=We;class Rt{constructor(e){T(this,"_store",void 0),T(this,"_refCount",0),T(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),yt(this._store,e)))),T(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),T(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return vt(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?pt.values():!0===e.isInitialized?vt(st([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):y(pt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),T(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),dt(this._store,this._store.getState().currentTree,e)))),T(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new kt(this);return e(t),Et(t.getStore_INTERNAL())})),T(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new kt(this);return await e(t),Et(t.getStore_INTERNAL())})),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return i(n.get(t));const o=ft();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().nodeCleanupFunctions.keys())lt(this._store,e.currentTree,t,"get"),St(this._store,t,1);this.retain(),this.autorelease_INTERNAL()}retain(){if(!S("recoil_memory_managament_2020"))return()=>{};this._refCount++;let e=!1;return()=>{e||(e=!0,this.release_INTERNAL())}}autorelease_INTERNAL(){S("recoil_memory_managament_2020")&&(ut||window.setTimeout((()=>this.release_INTERNAL()),0))}release_INTERNAL(){S("recoil_memory_managament_2020")&&(this._refCount--,this._refCount)}checkRefCount_INTERNAL(){S("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this.getID_INTERNAL()}getID_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function At(e,t,n=!1){const o=e.getState(),r=n?bt():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map,retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}function Et(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:i(n.previousTree);return new Rt(At(e,o))}class kt extends Rt{constructor(e){super(At(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),T(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();ct((()=>{St(n,e.key,1),_t(this.getStore_INTERNAL(),e,t)}))})),T(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();ct((()=>{St(t,e.key,1),_t(this.getStore_INTERNAL(),e,ht)}))})),T(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();ct((()=>{for(const[n,o]of e.entries())St(t,n,1),gt(t,new mt(n),o)}))}))}}var Nt={Snapshot:Rt,MutableSnapshot:kt,freshSnapshot:function(e){const t=new Rt(Tt());return null!=e?t.map(e):t},cloneSnapshot:Et},Vt=Nt.Snapshot,Mt=Nt.MutableSnapshot,Ct=Nt.freshSnapshot,Lt=Nt.cloneSnapshot,xt=Object.freeze({__proto__:null,Snapshot:Vt,MutableSnapshot:Mt,freshSnapshot:Ct,cloneSnapshot:Lt});const{getNextTreeStateVersion:Dt,makeEmptyStoreState:Bt}=We,{cleanUpNode:Ut,getDownstreamNodes:Ot,setNodeValue:It,setUnvalidatedAtomValue_DEPRECATED:Pt}=ee,{graph:zt}=xe,{cloneGraph:Ft}=xe,{applyAtomValueWrites:jt}=Se,{releaseScheduledRetainablesNow:Ht}=at,{freshSnapshot:$t}=xt,{useCallback:Gt,useContext:Wt,useEffect:qt,useMemo:Kt,useRef:Zt,useState:Jt}=a;function Xt(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const Qt=Object.freeze({getState:Xt,replaceState:Xt,getGraph:Xt,subscribeToTransactions:Xt,addTransactionMetadata:Xt});let Yt=!1;function en(e){if(Yt)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){S("recoil_memory_managament_2020")&&S("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Ht(e);const n=t.currentTree.version,o=Dt();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Ft(i(t.graphsByVersion.get(n))))}}const tn=a.createContext({current:Qt}),nn=()=>Wt(tn),on=a.createContext(null);function rn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,a]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of a)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);const r=Ot(e,n,o);for(const e of r){const o=t.nodeToComponentSubscriptions.get(e);if(o)for(const[e,[t,r]]of o)r(n)}t.suspendedComponentResolvers.forEach((e=>e()))}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function an({setNotifyBatcherOfChange:e}){const t=nn(),[n,o]=Jt([]);return e((()=>o({}))),qt((()=>{Ve.enqueueExecution("Batcher",(()=>{const e=t.current.getState();e.commitDepth++;try{const{nextTree:n}=e;if(null===n)return;e.previousTree=e.currentTree,e.currentTree=n,e.nextTree=null,rn(t.current);const o=i(e.previousTree).version;e.graphsByVersion.delete(o),e.previousTree=null,S("recoil_memory_managament_2020")&&Ht(t.current)}finally{e.commitDepth--}}))})),qt((()=>()=>{e((()=>{}))}),[e]),null}let sn=0;function un({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var r;let s;const u=Zt(null),c=Gt((e=>{u.current=e}),[u]),l=null!==(r=a.createMutableSource)&&void 0!==r?r:a.unstable_createMutableSource,d=null!==n&&void 0!==n?n:{getState:()=>s.current,replaceState:e=>{const t=f.current.getState();en(f.current);const n=i(t.nextTree);let o;try{Yt=!0,o=e(n)}finally{Yt=!1}o!==n&&(t.nextTree=o,i(u.current)())},getGraph:e=>{const t=s.current.graphsByVersion;if(t.has(e))return i(t.get(e));const n=zt();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=f.current.getState(),n=sn++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=f.current.getState();n.has(t)||n.set(t,new Map);const o=sn++;return i(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{en(f.current);for(const t of Object.keys(e))i(f.current.getState().nextTree).transactionMetadata[t]=e[t]}},f=Zt(d);s=Zt(null!=e?function(e,t){const n=Bt();return t({set:(t,o)=>{const r=n.currentTree,a=It(e,r,t.key,o),s=new Set(a.keys()),i=r.nonvalidatedAtoms.clone();for(const e of s)i.delete(e);n.currentTree={...r,dirtyAtoms:qe(r.dirtyAtoms,s),atomValues:jt(r.atomValues,a),nonvalidatedAtoms:i}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=Pt(n.currentTree,t,e)}))}}),n}(d,e):null!=t?function(e){return $t().map(e).getStore_INTERNAL().getState()}(t):Bt());const h=Kt((()=>l?l(s,(()=>s.current.currentTree.version)):null),[l,s]);return qt((()=>()=>{for(const e of f.current.getState().knownAtoms)Ut(f.current,e)}),[]),a.createElement(tn.Provider,{value:f},a.createElement(on.Provider,{value:h},a.createElement(an,{setNotifyBatcherOfChange:c}),o))}var cn={useStoreRef:nn,useRecoilMutableSource:function(){const e=Wt(on);return null==e&&b("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},RecoilRoot:function(e){const{override:t,...n}=e,o=nn();return!1===t&&o.current!==Qt?a.createElement(a.Fragment,null,e.children):a.createElement(un,n)},sendEndOfBatchNotifications_FOR_TESTING:rn};var ln=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var dn=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var fn=function(e,t){if(!e)throw new Error(t)};var hn,pn=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const vn=null!==(hn=a.useMutableSource)&&void 0!==hn?hn:a.unstable_useMutableSource;var mn={mutableSourceExists:function(){return vn&&!("undefined"!==typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:vn};var yn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useRef:_n}=a;var gn=function(){return _n(),"<component name not available>"};const{batchUpdates:Sn}=Ne,{DEFAULT_VALUE:wn,getNode:bn,nodes:Tn}=F,{useRecoilMutableSource:Rn,useStoreRef:An}=cn,{isRecoilValue:En}=L,{AbstractRecoilValue:kn,getRecoilValueAsLoadable:Nn,setRecoilValue:Vn,setRecoilValueLoadable:Mn,setUnvalidatedRecoilValue:Cn,subscribeToRecoilValue:Ln}=Se,{updateRetainCount:xn}=at,{RetentionZone:Dn}=H,{Snapshot:Bn,cloneSnapshot:Un}=xt,{setByAddingToSet:On}=m,{isSSR:In}=it,{mutableSourceExists:Pn,useMutableSource:zn}=mn,{useCallback:Fn,useEffect:jn,useMemo:Hn,useRef:$n,useState:Gn}=a,Wn=12e4;function qn(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:new Error(`Invalid value of loadable atom "${t.key}"`)}function Kn(e){return S("recoil_memory_managament_2020")&&oo(e),Pn()?function(e){const t=An(),n=Fn((()=>{const n=t.current,o=n.getState().currentTree;return Nn(n,e,o)}),[t,e]),o=Fn((()=>n()),[n]),r=gn(),a=Fn(((o,a)=>{const s=t.current;return Ln(s,e,(()=>{if(!S("recoil_suppress_rerender_in_callback"))return a();const e=n();u.current.is(e)||a(),u.current=e}),r).release}),[t,e,r,n]),s=Rn(),i=zn(s,o,a),u=$n(i);return jn((()=>{u.current=i})),i}(e):function(e){const t=An(),[n,o]=Gn([]),r=gn();jn((()=>{const n=t.current,a=n.getState(),i=Ln(n,e,(t=>{var r;if(!S("recoil_suppress_rerender_in_callback"))return o([]);const a=Nn(n,e,n.getState().currentTree);(null===(r=s.current)||void 0===r?void 0:r.is(a))||o(a),s.current=a}),r);if(a.nextTree)n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s.current=null,o([])}));else{var u;if(!S("recoil_suppress_rerender_in_callback"))return o([]);const t=Nn(n,e,n.getState().currentTree);(null===(u=s.current)||void 0===u?void 0:u.is(t))||o(t),s.current=t}return i.release}),[r,e,t]);const a=Nn(t.current,e),s=$n(a);return jn((()=>{s.current=a})),a}(e)}function Zn(e){const t=An();return qn(Kn(e),e,t)}function Jn(e){const t=An();return Fn((n=>{Vn(t.current,e,n)}),[t,e])}function Xn(e){const t=An();jn((()=>t.current.subscribeToTransactions(e).release),[e,t])}function Qn(e){const t=e.atomValues.toMap(),n=Ce(ln(t,((e,t)=>{const n=bn(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return pn(e.nonvalidatedAtoms.toMap(),n)}function Yn(e){const t=$n();return jn((()=>{t.current=e})),t.current}function eo(){const e=An();return Fn((t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Sn((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&bn(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{Mn(e.current,new kn(t),a.atomValues.has(t)?i(a.atomValues.get(t)):wn)})),e.current.replaceState((e=>({...e,stateID:t.getID_INTERNAL()})))}))}),[e])}class to{}const no=new to;function oo(e){if(S("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof Dn?e:e.key)),n=An();jn((()=>{if(!S("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!In)window.clearTimeout(o.current),o.current=null;else{v("Did not retain recoil value on render, or committed after timeout elapsed. This is fine, but odd.");for(const n of t)xn(e,n,1)}return()=>{for(const n of t)xn(e,n,-1)}}),[n,...t]);const o=$n(),r=Yn(t);if(!In&&(void 0===r||!yn(r,t))){const e=n.current;for(const n of t)xn(e,n,1);if(r)for(const t of r)xn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)xn(e,n,-1)}),Wn)}}(e)}var ro={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:eo,useRecoilCallback:function(e,t){const n=An(),o=eo();return Fn(((...t)=>{function r(e,t){Vn(n.current,e,t)}function a(e){Vn(n.current,e,wn)}const s=Un(n.current);let i=no;return Sn((()=>{const n="useRecoilCallback expects a function that returns a function: it accepts a function of the type (RecoilInterface) => T = R and returns a callback function T => R, where RecoilInterface is an object {snapshot, set, ...} and T and R are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof e)throw new Error(n);const u=e({set:r,reset:a,snapshot:s,gotoSnapshot:o});if("function"!==typeof u)throw new Error(n);i=u(...t)})),i instanceof to&&fn(!1),i}),null!=t?[...t,n]:void 0)},useRecoilInterface:function(){const e=An(),[t,n]=Gn([]),o=$n(new Set);o.current=new Set;const r=$n(new Set),a=$n(new Map),s=Fn((e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))}),[a]),i=gn();return jn((()=>{const t=e.current;function u(e,t){a.current.has(t)&&n([])}Me(o.current,r.current).forEach((e=>{if(a.current.has(e))return void b(`Double subscription to RecoilValue "${e}"`);const n=Ln(t,new kn(e),(t=>{u(0,e)}),i);a.current.set(e,n);t.getState().nextTree?t.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{u(t.getState(),e)})):u(t.getState(),e)})),Me(r.current,o.current).forEach((e=>{s(e)})),r.current=o.current})),jn((()=>{const e=a.current;return()=>e.forEach(((e,t)=>s(t)))}),[s]),Hn((()=>{function t(t){return n=>{Vn(e.current,t,n)}}function n(t){return o.current.has(t.key)||(o.current=On(o.current,t.key)),Nn(e.current,t)}function r(t){return qn(n(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[n(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>Vn(e.current,t,wn)}}}),[o,e])},useRecoilSnapshot:function(){const e=An(),[t,n]=Gn((()=>Un(e.current))),o=Yn(t),r=$n();return jn((()=>(r.current&&!In&&window.clearTimeout(r.current),t.retain())),[t]),Xn(Fn((e=>n(Un(e))),[])),o===t||In||(r.current&&(null===o||void 0===o||o.release_INTERNAL(),window.clearTimeout(r.current)),t.retain(),r.current=window.setTimeout((()=>{t.release_INTERNAL(),r.current=null}),Wn)),t},useRecoilState:function(e){return[Zn(e),Jn(e)]},useRecoilStateLoadable:function(e){return[Kn(e),Jn(e)]},useRecoilTransactionObserver:function(e){Xn(Fn((t=>{const n=Un(t,"current"),o=Un(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useRecoilValue:Zn,useRecoilValueLoadable:Kn,useRetain:oo,useResetRecoilState:function(e){const t=An();return Fn((()=>{Vn(t.current,e,wn)}),[t,e])},useSetRecoilState:Jn,useSetUnvalidatedAtomValues:function(){const e=An();return(t,n={})=>{Sn((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>Cn(e.current,new kn(n),t)))}))}},useTransactionObservation_DEPRECATED:function(e){Xn(Fn((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(v("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=Qn(o),a=Qn(n),s=Ce(Tn,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=dn(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:Xn};const{peekNodeInfo:ao}=ee,{useStoreRef:so}=cn;var io=function(){const e=so();return({key:t})=>ao(e.current,e.current.getState().currentTree,t)};const{RecoilRoot:uo,useStoreRef:co}=cn,{useMemo:lo}=a;var fo=function(){const e=co().current;return lo((()=>function({children:t}){return a.createElement(uo,{store_INTERNAL:e},t)}),[e])};const{isReactNative:ho,isSSR:po}=it;function vo(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(s(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>vo(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return vo(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:vo(n,t)]=r;return vo(o,t,n)}return e instanceof Set?vo(Array.from(e).sort(((e,n)=>vo(e,t).localeCompare(vo(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?vo(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${vo(n,t)}:${vo(e[n],t,n)}`)).join(",")}}`}var mo=function(e,t={allowFunctions:!1}){return vo(e,t)};const yo=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return yo(e.branches.get(r),t,n)},_o=(e,t,n,o,r,a)=>{var s;let i;if(null==e)if(0===t.length)i={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...s]=t,[u,c]=e;i={type:"branch",nodeKey:u,parent:n,branches:new Map,branchKey:r},i.branches.set(c,_o(null,s,i,o,c,a))}else if(i=e,t.length){const[n,...r]=t,[s,i]=n;("branch"!==e.type||e.nodeKey!==s)&&fn(!1),e.branches.set(i,_o(e.branches.get(i),r,e,o,i,a))}return null===a||void 0===a||null===(s=a.onNodeVisit)||void 0===s||s.call(a,i),i},go=(e,t,n)=>n?(n.branches.delete(t.branchKey),So(e,n,n.parent)):e===t,So=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),So(e,n,n.parent)):e===t,wo=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+wo(t)),0);var bo=class{constructor(e){var t,n,o;T(this,"_numLeafs",void 0),T(this,"_root",void 0),T(this,"_onHit",void 0),T(this,"_onSet",void 0),T(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return yo(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o;const r=_o(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}});this.root()||(this._root=r),this._numLeafs++,this._onSet(i(o))}delete(e){if(!this.root())return!1;const t=i(this.root());return!!go(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=wo(e),!0))}clear(){this._numLeafs=0,this._root=null}},To=Object.freeze({__proto__:null,TreeCache:bo});var Ro=class{constructor(e){var t;T(this,"_maxSize",void 0),T(this,"_size",void 0),T(this,"_head",void 0),T(this,"_tail",void 0),T(this,"_map",void 0),T(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=i(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Ao=Object.freeze({__proto__:null,LRUCache:Ro});const{LRUCache:Eo}=Ao,{TreeCache:ko}=To;var No=function(e,t=(e=>e)){const n=new Eo({maxSize:e}),o=new ko({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};const{TreeCache:Vo}=To,Mo={equality:"reference",eviction:"none",maxSize:1/0};var Co=function({equality:e=Mo.equality,eviction:t=Mo.eviction,maxSize:n=Mo.maxSize}=Mo){return function(e,t,n){switch(e){case"none":return new Vo({mapNodeValue:n});case"lru":return No(i(t),n)}throw new Error(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>mo(e)}throw new Error(`Unrecognized equality policy ${e}`)}(e))};var Lo={startPerfBlock:function(e){return()=>null}};const{CANCELED:xo,Canceled:Do,loadableWithError:Bo,loadableWithPromise:Uo,loadableWithValue:Oo}=p,{getNodeLoadable:Io,peekNodeLoadable:Po,setNodeValue:zo}=ee,{saveDependencyMapToStore:Fo}=xe,{DEFAULT_VALUE:jo,RecoilValueNotReady:Ho,getConfigDeletionHandler:$o,registerNode:Go}=F,{isRecoilValue:Wo}=L,{AbstractRecoilValue:qo}=L,{setRecoilValueLoadable:Ko}=Se,{retainedByOptionWithDefault:Zo}=at,{cloneSnapshot:Jo}=xt,{startPerfBlock:Xo}=Lo,Qo=[],Yo=new Map,er=(()=>{let e=0;return()=>e++})();var tr=function(e){const{key:t,get:n,cachePolicy_UNSTABLE:o}=e,r=null!=e.set?e.set:void 0,a=Co(null!==o&&void 0!==o?o:{equality:"reference",eviction:"none"}),u=Zo(e.retainedBy_UNSTABLE),c=new Map;let l=0;function d(){return!S("recoil_memory_managament_2020")||l>0}function f(e){return c.has(e)||c.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null}),i(c.get(e))}function h(e){return l++,e.getState().knownSelectors.add(t),()=>{l--,e.getState().knownSelectors.delete(t),c.delete(e)}}function p(){return void 0!==$o(t)&&!d()}function m(e,t,n){if("loading"===t.state){let t=Yo.get(n);null==t&&Yo.set(n,t=new Set),t.add(e)}}function y(e,t,n){if(t.atomValues.has(n))return i(t.atomValues.get(n));const o=Io(e,t,n),r=e.getState().knownSelectors.has(n);return"loading"!==o.state&&r&&t.atomValues.set(n,o),o}function _(e,n,o,r,a){return n.then((n=>{if(!d())return V(e,a),xo;if(n instanceof Do)return v("Selector was released while it had dependencies"),xo;const{__key:r,__value:s}=null!==n&&void 0!==n?n:{};let i=!0;null!=r&&(o.atomValues.set(r,Oo(s)),i=!1);const[u,c]=b(e,o,a,i);if(M(e,a)&&N(c,e,a),C(u),"loading"!==u.state&&(x(o,T(c),u),w(e,o,new Set(c.keys()),a),g(e,u,a)),"hasError"===u.state)throw u.contents;return"hasValue"===u.state?{__value:u.contents,__key:t}:u.contents})).catch((t=>{if(!d())return V(e,a),xo;const n=Bo(t);throw L(t),x(o,T(r),Bo(t)),w(e,o,new Set(r.keys()),a),g(e,n,a),t}))}function g(e,n,o){M(e,o)&&(k(n,e),function(e,n){const o=Yo.get(n);if(void 0!==o){for(const n of o)Ko(n,new qo(t),e);Yo.delete(n)}}(n,o))}function w(e,n,o,r){var a,s,i,u,c,l,d;(M(e,r)||n.version===(null===(a=e.getState())||void 0===a||null===(s=a.currentTree)||void 0===s?void 0:s.version)||n.version===(null===(i=e.getState())||void 0===i||null===(u=i.nextTree)||void 0===u?void 0:u.version))&&Fo(new Map([[t,o]]),e,null!==(c=null===(l=e.getState())||void 0===l||null===(d=l.nextTree)||void 0===d?void 0:d.version)&&void 0!==c?c:e.getState().currentTree.version)}function b(e,o,r,a=!1){const i=Xo(t);let u,c,l=!1;const f=new Map,h=new Set;function p(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),w(e,t,n,r)}(e,o,h,n,r);const s=a?Io(e,o,n):y(e,o,n);if(C(s),f.set(n,s),"hasValue"===s.state)return s.contents;throw s.contents}w(e,o,h,r);let v=!1;const m=t=>(...n)=>{if(!v)throw new Error("getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can obtain the current Recoil state without a subscription.");const o=Jo(e),r=t({snapshot:o});if("function"!==typeof r)throw new Error("getCallback() expects a function that returns a function.");return r(...n)};try{u=n({get:p,getCallback:m}),u=Wo(u)?p(u):u,v=!0,s(u)?u=function(e,n,o,r,a){return n.then((n=>{if(!d())return V(e,a),xo;const s=Oo(n);return L(n),x(o,T(r),s),w(e,o,new Set(r.keys()),a),g(e,s,a),{__value:n,__key:t}})).catch((t=>{if(!d())return V(e,a),xo;if(M(e,a)&&N(r,e,a),s(t))return _(e,t,o,r,a);const n=Bo(t);throw L(t),x(o,T(r),n),w(e,o,new Set(r.keys()),a),g(e,n,a),t}))}(e,u,o,f,r).finally(i):i()}catch(S){u=S,s(u)?u=_(e,u,o,f,r).finally(i):(l=!0,i())}return c=l?Bo(u):s(u)?Uo(u):Oo(u),C(c),[c,f]}function T(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}function R(e,t){const n=er(),[o,r]=b(e,t,n);return k(o,e,r,n,t),function(e,t,n){"loading"!==n.state&&x(e,t,n)}(t,T(r),o),m(e,o,n),o}function A(e,n){const o=function(e,n){const o=new Set,r=f(e),s=a.get((t=>("string"!==typeof t&&fn(!1),y(e,n,t).contents)),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==t&&"string"===typeof e.nodeKey&&o.add(e.nodeKey)}});return s&&w(e,n,o,r.latestExecutionId),s}(e,n);if(null!=o)return k(o,e),o;const r=function(e,t){var n;const[,o]=null!==(n=Array.from(c.entries()).find((([,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=f(e),a=null!==(n=r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,s=Array((null!==(o=E.get(t.version))&&void 0!==o?o:new Map).entries()),i=E.has(t.version)&&s.length===a.size&&s.every((([e,t])=>a.get(e)===t));if(null==a||t.version===r.stateVersion||i)return!1;return E.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>{const r=y(e,t,n);return r.contents!==o.contents&&!("loading"===o.state&&"loading"!==r.state)}))}(e,t))))&&void 0!==n?n:[];return o}(e,n);if(r){const t=r;return m(e,i(t.latestLoadable),i(t.latestExecutionId)),i(t.latestLoadable)}return R(e,n)}const E=new Map;function k(e,t,n,o,r){const a=f(t);"loading"===e.state?(a.depValuesDiscoveredSoFarDuringAsyncWork=n,a.latestExecutionId=o,a.latestLoadable=e,a.stateVersion=null===r||void 0===r?void 0:r.version):(a.depValuesDiscoveredSoFarDuringAsyncWork=null,a.latestExecutionId=null,a.latestLoadable=null,a.stateVersion=null)}function N(e,t,n){const o=f(t);M(t,n)&&(o.depValuesDiscoveredSoFarDuringAsyncWork=e)}function V(e,t){M(e,t)&&c.delete(e)}function M(e,t){return t===f(e).latestExecutionId}function C(e){"loading"!==e.state&&L(e.contents)}function L(e){0}function x(e,n,o){e.atomValues.set(t,o),a.set(n,o)}function D(e,t){return a.get((n=>{"string"!==typeof n&&fn(!1);const o=Po(e,t,n);return null===o||void 0===o?void 0:o.contents}))}function B(e,n){return function(e){if(Qo.includes(t)){const e=`Recoil selector has circular dependencies: ${Qo.slice(Qo.indexOf(t)).join(" \u2192 ")}`;return Bo(new Error(e))}Qo.push(t);try{return e()}finally{Qo.pop()}}((()=>A(e,n)))}function U(e){e.atomValues.delete(t)}if(null!=r){return Go({key:t,peek:D,get:B,set:(e,t,n)=>{let o=!1;const a=new Map;function i({key:n}){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const r=y(e,t,n);if(C(r),"hasValue"===r.state)return r.contents;throw"loading"===r.state?new Ho(n):r.contents}function u(n,r){if(o)throw new Error("Recoil: Async selector sets are not currently supported.");const s="function"===typeof r?r(i(n)):r;zo(e,t,n.key,s).forEach(((e,t)=>a.set(t,e)))}const c=r({set:u,get:i,reset:function(e){u(e,jo)}},n);if(void 0!==c)throw s(c)?new Error("Recoil: Async selector sets are not currently supported."):new Error("Recoil: selector set should be a void function.");return o=!0,a},init:h,invalidate:U,shouldDeleteConfigOnRelease:p,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}return Go({key:t,peek:D,get:B,init:h,invalidate:U,shouldDeleteConfigOnRelease:p,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})};const{loadableWithError:nr,loadableWithPromise:or,loadableWithValue:rr}=p,{DEFAULT_VALUE:ar,DefaultValue:sr,getConfigDeletionHandler:ir,registerNode:ur,setConfigDeletionHandler:cr}=F,{isRecoilValue:lr}=L,{markRecoilValueModified:dr,setRecoilValue:fr,setRecoilValueLoadable:hr}=Se,{retainedByOptionWithDefault:pr}=at;function vr(e){const{key:t,persistence_UNSTABLE:n}=e,o=pr(e.retainedBy_UNSTABLE);let r,a=0,u=s(e.default)?or(e.default.then((e=>{u=rr(e);return{__key:t,__value:e}})).catch((e=>{throw u=nr(e),e}))):rr(e.default);const c=new Map;const l=ur({key:t,peek:function(e,n){var o,a,s;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:null===(s=r)||void 0===s?void 0:s[1])&&void 0!==o?o:u},get:function(e,o){if(o.atomValues.has(t))return i(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return b(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),u;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,ar),s=a instanceof sr?u:rr(a);return r=s,r}return u},set:function(e,n,o){if(n.atomValues.has(t)){const e=i(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof sr)return new Map;return r=void 0,(new Map).set(t,rr(o))},init:function(n,o,r){a++;const i=n.getState().knownAtoms.has(t);if(n.getState().knownAtoms.add(t),"loading"===u.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||dr(n,l)};u.contents.then(e).catch(e)}let d=ar,f=null;if(null!=e.effects_UNSTABLE&&!i){let o=!0;const a=e=>t=>{if(o){const n=d instanceof sr||s(d)?"hasValue"===u.state?u.contents:ar:d;d="function"===typeof t?t(n):t,s(d)&&(d=d.then((t=>(f={effect:e,value:t},t))))}else{if(s(t))throw new Error("Setting atoms to async values is not implemented.");"function"!==typeof t&&(f={effect:e,value:t}),fr(n,l,"function"===typeof t?n=>{const o=t(n);return f={effect:e,value:o},o}:t)}},i=e=>()=>a(e)(ar),p=e=>o=>{n.subscribeToTransactions((n=>{let{currentTree:r,previousTree:a}=n.getState();a||(v("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),a=r);const s=r.atomValues.get(t);if(null==s||"hasValue"===s.state){var i,c,l,d;const n=null!=s?s.contents:ar,r=null!==(i=a.atomValues.get(t))&&void 0!==i?i:u,h="hasValue"===r.state?r.contents:ar;(null===(c=f)||void 0===c?void 0:c.effect)!==e||(null===(l=f)||void 0===l?void 0:l.value)!==n?o(n,h):(null===(d=f)||void 0===d?void 0:d.effect)===e&&(f=null)}}),t)};for(const t of null!==(h=e.effects_UNSTABLE)&&void 0!==h?h:[]){var h;const e=t({node:l,trigger:r,setSelf:a(t),resetSelf:i(t),onSet:p(t)});null!=e&&c.set(n,e)}o=!1}if(!(d instanceof sr)){var p;const e=s(d)?or(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&fr(e,l,n),{__key:t,__value:n}})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&hr(e,l,nr(n)),n}));return o}(n,d)):rr(d);o.atomValues.set(t,e),null===(p=n.getState().nextTree)||void 0===p||p.atomValues.set(t,e)}return()=>{var e;a--,null===(e=c.get(n))||void 0===e||e(),c.delete(n),n.getState().knownAtoms.delete(t)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==ir(t)&&a<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return l}function mr(e){const{default:t,...n}=e;return lr(t)?function(e){const t=mr({...e,default:ar,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof sr?t:i(e.persistence_UNSTABLE).validator(t,ar)},effects_UNSTABLE:e.effects_UNSTABLE}),n=tr({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof sr?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return cr(n.key,ir(e.key)),n}({...n,default:t}):vr({...n,default:t})}var yr=mr;var _r=class{constructor(e){var t;T(this,"_map",void 0),T(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},gr=Object.freeze({__proto__:null,MapCache:_r});const{LRUCache:Sr}=Ao,{MapCache:wr}=gr,br={equality:"reference",eviction:"none",maxSize:1/0};var Tr=function({equality:e=br.equality,eviction:t=br.eviction,maxSize:n=br.maxSize}=br){return function(e,t,n){switch(e){case"none":return new wr({mapKey:n});case"lru":return new Sr({mapKey:n,maxSize:i(t)})}throw new Error(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>mo(e)}throw new Error(`Unrecognized equality policy ${e}`)}(e))};const{setConfigDeletionHandler:Rr}=F;var Ar=function(e){var t;const n=Tr(null!==(t=e.cachePolicyForParams_UNSTABLE)&&void 0!==t?t:{equality:"value",eviction:"none"});return t=>{var o;const r=n.get(t);if(null!=r)return r;const{cachePolicyForParams_UNSTABLE:a,...s}=e,i=yr({...s,key:`${e.key}__${null!==(o=mo(t))&&void 0!==o?o:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects_UNSTABLE:"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):e.effects_UNSTABLE});return n.set(t,i),Rr(i.key,(()=>{n.delete(t)})),i}};const{setConfigDeletionHandler:Er}=F;let kr=0;var Nr=function(e){var t;const n=Tr(null!==(t=e.cachePolicyForParams_UNSTABLE)&&void 0!==t?t:{equality:"value",eviction:"none"});return t=>{var o;const r=n.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(o=mo(t,{allowFunctions:!0}))&&void 0!==o?o:"void"}/${kr++}`,s=n=>e.get(t)(n),i=e.cachePolicy_UNSTABLE,u="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=tr({key:a,get:s,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=tr({key:a,get:s,cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return n.set(t,c),Er(c.key,(()=>{n.delete(t)})),c}};const Vr=Nr({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Mr=function(e){return Vr(e)};const Cr=Nr({key:"__error",get:e=>()=>{throw new Error(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Lr=function(e){return Cr(e)};var xr=function(e){return e};const{loadableWithError:Dr,loadableWithPromise:Br,loadableWithValue:Ur}=p;function Or(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,s]of t.entries())try{n[a]=e(s)}catch(r){o[a]=r}return[n,o]}function Ir(e){return null!=e&&!s(e)}function Pr(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function zr(e){return null!=e&&"object"===typeof e&&e.hasOwnProperty("__value")?e.__value:e}function Fr(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function jr(e,t,n){return Fr(e,n.map(((e,n)=>null==e?Ur(t[n]):s(e)?Br(e):Dr(e))))}var Hr={waitForNone:Nr({key:"__waitForNone",get:e=>({get:t})=>{const n=Pr(e),[o,r]=Or(t,n);return jr(e,o,r)}}),waitForAny:Nr({key:"__waitForAny",get:e=>({get:t})=>{const n=Pr(e),[o,r]=Or(t,n);return r.some((e=>!s(e)))?jr(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())s(a)&&a.then((a=>{o[n]=zr(a),r[n]=void 0,t(jr(e,o,r))})).catch((a=>{r[n]=a,t(jr(e,o,r))}))}))}}),waitForAll:Nr({key:"__waitForAll",get:e=>({get:t})=>{const n=Pr(e),[o,r]=Or(t,n);if(r.every((e=>null==e)))return Fr(e,o);const a=r.find(Ir);if(null!=a)throw a;return Promise.all(r).then((t=>{return Fr(e,(n=o,r=t,r.map(((e,t)=>void 0===e?n[t]:e))).map(zr));var n,r}))}}),waitForAllSettled:Nr({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Pr(e),[o,r]=Or(t,n);return r.every((e=>!s(e)))?jr(e,o,r):Promise.all(r.map(((e,t)=>s(e)?e.then((e=>{o[t]=zr(e),r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>jr(e,o,r)))}}),noWait:Nr({key:"__noWait",get:e=>({get:t})=>{try{return Ur(t(e))}catch(n){return s(n)?Br(n):Dr(n)}}})};const{batchUpdates:$r,setBatcher:Gr}=Ne,{DefaultValue:Wr}=F,{RecoilRoot:qr}=cn,{isRecoilValue:Kr}=L,{retentionZone:Zr}=H,{freshSnapshot:Jr}=xt,{useGotoRecoilSnapshot:Xr,useRecoilCallback:Qr,useRecoilSnapshot:Yr,useRecoilState:ea,useRecoilStateLoadable:ta,useRecoilTransactionObserver:na,useRecoilValue:oa,useRecoilValueLoadable:ra,useResetRecoilState:aa,useRetain:sa,useSetRecoilState:ia,useSetUnvalidatedAtomValues:ua,useTransactionObservation_DEPRECATED:ca}=ro,{noWait:la,waitForAll:da,waitForAllSettled:fa,waitForAny:ha,waitForNone:pa}=Hr;var va={DefaultValue:Wr,RecoilRoot:qr,useRecoilBridgeAcrossReactRoots_UNSTABLE:fo,atom:yr,selector:tr,retentionZone:Zr,atomFamily:Ar,selectorFamily:Nr,constSelector:Mr,errorSelector:Lr,readOnlySelector:xr,useRecoilValue:oa,useRecoilValueLoadable:ra,useRecoilState:ea,useRecoilStateLoadable:ta,useSetRecoilState:ia,useResetRecoilState:aa,useGetRecoilValueInfo_UNSTABLE:io,useRetain:sa,useRecoilCallback:Qr,useGotoRecoilSnapshot:Xr,useRecoilSnapshot:Yr,useRecoilTransactionObserver_UNSTABLE:na,useTransactionObservation_UNSTABLE:ca,useSetUnvalidatedAtomValues_UNSTABLE:ua,noWait:la,waitForNone:pa,waitForAny:ha,waitForAll:da,waitForAllSettled:fa,isRecoilValue:Kr,batchUpdates:$r,setBatcher:Gr,snapshot_UNSTABLE:Jr},ma=va.RecoilRoot,ya=n(5893);function _a({Component:e,pageProps:t}){const n=e.getLayout||(e=>e);return(0,ya.jsxs)(ya.Fragment,{children:[(0,ya.jsxs)(o.default,{children:[(0,ya.jsx)("meta",{charSet:"utf-8"}),(0,ya.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1, shrink-to-fit=no"}),(0,ya.jsx)("meta",{name:"application-name",content:""}),(0,ya.jsx)("meta",{name:"description",content:""}),(0,ya.jsx)("meta",{name:"author",content:"Ryota Mizumaki"}),(0,ya.jsx)("meta",{name:"rating",content:"General"}),(0,ya.jsx)("meta",{name:"mobile-web-app-capable",content:"yes"}),(0,ya.jsx)("meta",{name:"apple-mobile-web-app-capable",content:"yes"}),(0,ya.jsx)("meta",{name:"apple-mobile-web-app-capable-status-bar-style",content:"black-translucent"}),(0,ya.jsx)("meta",{name:"theme-color",content:"#152231"}),(0,ya.jsx)("meta",{property:"og:type",content:"article"}),(0,ya.jsx)("meta",{name:"twitter:site",content:"@RyotaMizumaki"}),(0,ya.jsx)("meta",{name:"twitter:card",content:"summary"}),(0,ya.jsx)("link",{rel:"preload",href:"/fonts/x16y32pxGridGazer.ttf",as:"font"}),(0,ya.jsx)("link",{rel:"preload",href:"/fonts/x12y16pxMaruMonica.ttf",as:"font"})]}),(0,ya.jsx)(ma,{children:n((0,ya.jsx)(e,{...t}))})]})}},6363:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/_app",function(){return n(5912)}])},2989:function(){},8701:function(){},9008:function(e,t,n){e.exports=n(2717)}},function(e){var t=function(t){return e(e.s=t)};e.O(0,[774,179],(function(){return t(6363),t(9898)}));var n=e.O();_N_E=n}]);